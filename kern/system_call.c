/**
 * @file system_call.c
 * @author Tony Xi (xiaolix)
 * @author Zekun Ma (zekunm)
 * @brief System call handlers.
 */

#include <system_call.h> // handle_gettid
#include <ctrl_blk.h> // thread_lists
#include <loader.h> // load_executable
#include <ureg.h> // ureg_t
#include <simics.h> // lprintf
#include <stdbool.h> // true
#include <stop_stub.h> // stop
#include <scheduler.h> // find_next_thread
#include <context_switcher.h> // switch_context
#include <console.h> // putbytes
#include <common_kern.h> // USER_MEM_START
#include <stdint.h> // uint32_t
#include <mutex.h> // mutex_t
#include <asm.h> // disable_interrupts
#include <keyboard.h> // scancode_buf
#include <keyhelp.h> // KHE_BACKSPACE
#include <scheduler.h> // find_next_thread
#include <context_switcher.h> // switch_context
#include <page.h> // PAGE_SHIFT
#include <vm.h> // set_availability
#include <cr.h> // get_cr3
#include <string.h> // memset
#include <seg.h> // SEGSEL_KERNEL_CS
#include <execution_state.h> // load_ureg
#include <eflags.h> // EFL_IOPL_SHIFT
#include <timer.h> // tick_count

// Minimum size of user provided exception stack.
// 7 stands for esp, ureg_ptr, arg, eax, ecx, edx, eip that should be
// pushed onto the stack.
#define EXCEPTION_STACK_SIZE_MIN (sizeof(ureg_t) + 7 * sizeof(uint32_t))
// Minimum number of bytes to be checked for user provided handler.
#define HANDLER_SIZE_MIN (1)

// width of IOPL bits in eflags register
#define IOPL_WIDTH (2)

/**
 * @brief This buffer holds characters that are generated by parsing
 *        augmented characters. getchar and readline may communicate
 *        over this buffer.
 * 
 * This buffer should be manipulated via push_tail, pop_head and
 * pop_tail.
 */
buf_t ch_buf = {.start_idx = 0};
/**
 * @brief control exclusive access to ch_buf in readline
 */
mutex_t input_lock;
/**
 * @brief control exclusive access to interaction with console
 */
mutex_t output_lock;

/**
 * @brief Test if a range of memory referenced by user is writable.
 * 
 * @param addr memory start
 * @param size memory size
 * @return whether the memory is accessible for writing
 */
bool is_writable(uint32_t addr, uint32_t size);
/**
 * @brief Test if a range of memory referenced by user is readable.
 * 
 * @param addr memory start
 * @param size memory size
 * @return whether the memory is accessible for reading
 */
bool is_readable(uint32_t addr, uint32_t size);

bool is_writable(uint32_t addr, uint32_t size) {
    if (size > 0) {
        if (!(addr >= USER_MEM_START && size <= VIRTUAL_ADDR_END - addr)) {
            return false;
        }

        pde_t *page_dir = (pde_t *)((get_cr3() >> PAGE_SHIFT) << PAGE_SHIFT);
        for (
            uint64_t i = (addr >> PAGE_SHIFT) << PAGE_SHIFT;
            i < (uint64_t)addr + (uint64_t)size;
            i += PAGE_SIZE
        ) {
            mapping_info_t mapping_info;
            check_user_page(page_dir, i, &mapping_info);
            switch (mapping_info) {
                case PDE_NOT_PRESENT:
                case PTE_NOT_PRESENT: {
                    uint32_t availability;
                    get_availability(page_dir, i, &availability);
                    if (availability != PAGE_AVAILABLE) {
                        return false;
                    }
                    break;
                }
                case ZERO_FRAME_MAPPED: {
                    break;
                }
                case NEW_FRAME_MAPPED: {
                    uint32_t access;
                    get_access(page_dir, i, &access);
                    if (access != READ_WRITE) {
                        return false;
                    }
                    break;
                }
                default: {
                    return false;
                }
            }
        }
    }

    return true;
}

bool is_readable(uint32_t addr, uint32_t size) {
    if (size > 0) {
        if (!(addr >= USER_MEM_START && size <= VIRTUAL_ADDR_END - addr)) {
            return false;
        }

        pde_t *page_dir = (pde_t *)((get_cr3() >> PAGE_SHIFT) << PAGE_SHIFT);
        for (
            uint64_t i = (addr >> PAGE_SHIFT) << PAGE_SHIFT;
            i < (uint64_t)addr + (uint64_t)size;
            i += PAGE_SIZE
        ) {
            mapping_info_t mapping_info;
            check_user_page(page_dir, i, &mapping_info);
            switch (mapping_info) {
                case PDE_NOT_PRESENT:
                case PTE_NOT_PRESENT: {
                    uint32_t availability;
                    get_availability(page_dir, i, &availability);
                    if (availability != PAGE_AVAILABLE) {
                        return false;
                    }
                }
                case ZERO_FRAME_MAPPED:
                case NEW_FRAME_MAPPED: {
                    break;
                }
                default: {
                    return false;
                }
            }
        }
    }

    return true;
}

bool check_eflags(uint32_t old_eflags, uint32_t new_eflags) {
    uint32_t iopl_mask = ~((~0 >> IOPL_WIDTH) << IOPL_WIDTH) << EFL_IOPL_SHIFT;
    return (old_eflags & iopl_mask) == (new_eflags & iopl_mask);
}

int initialize_system_call(void) {
    if (
        mutex_init(&input_lock) < 0 ||
        mutex_init(&output_lock) < 0
    ) {
        return -1;
    }
    return 0;
}

void handle_gettid(ureg_t *ureg_ptr) {
    tcb_t *tcb_ptr = thread_lists[RUNNING_STATE]->data;
    ureg_ptr->eax = tcb_ptr->tid;
}

void handle_fork(ureg_t *ureg_ptr) {
    // reject multi-threading processes
    tcb_t *tcb_ptr = thread_lists[RUNNING_STATE]->data;
    pcb_t *pcb_ptr = tcb_ptr->pcb_ptr;
    mutex_lock(&(pcb_ptr->lock));
    int thread_alive_count;
    bool single_threading = 
        !(get_thread_alive_count(tcb_ptr->pcb_ptr, &thread_alive_count) < 0) &&
        thread_alive_count == 1;
    mutex_unlock(&(pcb_ptr->lock));
    if (!single_threading) {
        ureg_ptr->eax = -1;
        return;
    }

    int new_tid = fork_ctrl_blk(ureg_ptr);
    if(new_tid < 0) {
        ureg_ptr->eax = -1;
    } else {
        ureg_ptr->eax = new_tid;
    }
}

void handle_exec(ureg_t *ureg_ptr) {
    // reject multi-threading processes
    tcb_t *tcb_ptr = thread_lists[RUNNING_STATE]->data;
    pcb_t *pcb_ptr = tcb_ptr->pcb_ptr;
    mutex_lock(&(pcb_ptr->lock));
    int thread_alive_count;
    bool single_threading = 
        !(get_thread_alive_count(tcb_ptr->pcb_ptr, &thread_alive_count) < 0) &&
        thread_alive_count == 1;
    mutex_unlock(&(pcb_ptr->lock));
    if (!single_threading) {
        ureg_ptr->eax = -1;
        return;
    }

    void **arg_array = (void **)ureg_ptr->esi;
    char *execname = arg_array[0];
    char **argvec = arg_array[1];
    if (load_executable(execname, argvec, ureg_ptr) < 0) {
        ureg_ptr->eax = -1;
        return;
    }

    // de-register swexn handler
    tcb_ptr->handler = NULL;
}

void handle_halt(ureg_t *ureg_ptr) {
    sim_halt();
    stop();
}

void handle_deschedule(ureg_t *ureg_ptr){
    ureg_ptr->eax = 0;
    pcb_t *pcb_ptr = thread_lists[RUNNING_STATE]->data->pcb_ptr;
    int *reject = (int*) ureg_ptr->esi;

    // Check for valid pointer
    if(!is_readable((uint32_t) reject, sizeof(int))){
        ureg_ptr->eax = -1;
        return;
    }

    // Atomically check reject
    mutex_lock(&(pcb_ptr->lock));
    disable_interrupts();

    int val = *reject;
    if (val)
    {
        mutex_unlock(&(pcb_ptr->lock));
        enable_interrupts();
        return;
    }
    
    blocking_detail_t detail = (blocking_detail_t) {.reason = DESCHEDULE};
    tcb_t *next_tcb = find_next_thread();
    if (next_tcb == NULL)
    {
        ureg_t ureg = {.cause = 0};
        handle_halt(&ureg);
    }
    
    mutex_unlock(&(pcb_ptr->lock));
    switch_context(next_tcb, WAITING_STATE, &detail);
    enable_interrupts();
}

void handle_make_runnable(ureg_t *ureg_ptr){
    int tid = ureg_ptr->esi;

    // Find corresponding descheduled thread
    disable_interrupts();
    tcb_t *tcb_ptr = find_tcb_in_list((void*) tid, DESCHEDULE);
    if (tcb_ptr == NULL)
    {
        ureg_ptr->eax = -1;
        enable_interrupts();
        return;
    }

    // Make descheduled thread runnable 
    alter_state(tcb_ptr, READY_STATE, NULL);
    enable_interrupts();

    ureg_ptr->eax = 0;
}

void handle_yield(ureg_t *ureg_ptr){
    int tid = ureg_ptr->esi;
    disable_interrupts();
    if (tid == -1)
    {
        tcb_t *next_tcb = round_robin();
        if (next_tcb == NULL)
        {
            ureg_ptr->eax = -1;
            enable_interrupts();
            return;
        }
        switch_context(next_tcb, READY_STATE, NULL);
    }else{
        tcb_t *tcb_ptr = find_tcb_in_list((void*) tid, READY_STATE);
        if (tcb_ptr == NULL)
        {
            ureg_ptr->eax = -1;
            enable_interrupts();
            return;
        }
        switch_context(tcb_ptr, READY_STATE, NULL);
    }
    enable_interrupts();
    ureg_ptr->eax = 0;
}

void handle_wait(ureg_t *ureg_ptr) {
    int *status_ptr = (int*) ureg_ptr->esi;

    // Check if memeory is writable
    if (status_ptr && !is_writable((uint32_t) status_ptr, sizeof(int)))
    {
        ureg_ptr->eax = -1;
        return;
    }

    pcb_t *pcb_ptr = thread_lists[RUNNING_STATE]->data->pcb_ptr;

    mutex_lock(&(pcb_ptr->lock));
    pcb_node_t *child_pcb_node;
    while (true)
    {
        if (pcb_ptr->child_pcb_list == NULL)
        {
            // no more children, fail
            ureg_ptr->eax = -1;
            mutex_unlock(&(pcb_ptr->lock));
            return;
        }

        // Loop through child processes and find an exited one
        child_pcb_node = find_exited_child(pcb_ptr);

        if (child_pcb_node)
        {
            unlock_children(pcb_ptr, child_pcb_node);
            break;
        }else{
            // Block and wait
            blocking_detail_t detail = (blocking_detail_t) {.reason = VANISH_WAIT};
            
            disable_interrupts();
            unlock_children(pcb_ptr, NULL);

            tcb_t *next_tcb = find_next_thread();
            if (next_tcb == NULL)
            {
                ureg_t ureg = {.cause = 0};
                handle_halt(&ureg);
            }
            
            mutex_unlock(&(pcb_ptr->lock));
            switch_context(next_tcb, WAITING_STATE, &detail);
            enable_interrupts();
            mutex_lock(&(pcb_ptr->lock));
        }
    }
    
    // detach node
    if (child_pcb_node == child_pcb_node->next)
    {
        // Only one task left in parent
        pcb_ptr->child_pcb_list = NULL;
    }else{
        if (pcb_ptr->child_pcb_list == child_pcb_node)
        {
            pcb_ptr->child_pcb_list = child_pcb_node->next;
        }
        
        child_pcb_node->next->previous = child_pcb_node->previous;
        child_pcb_node->previous->next = child_pcb_node->next;

        child_pcb_node->next = child_pcb_node;
        child_pcb_node->previous = child_pcb_node;
    }

    pcb_t *child_pcb = &(child_pcb_node->data);

    // append grandchildren to init
    pcb_t *init_pcb = &(root_pcb_node_ptr->data.child_pcb_list->data);
    if (pcb_ptr != init_pcb)
    {
        mutex_lock(&(init_pcb->lock));
    }
    
    pcb_node_t *children = init_pcb->child_pcb_list;
    pcb_node_t *grandchildren = child_pcb->child_pcb_list;

    if (grandchildren)
    {
        if(children == NULL){
            pcb_ptr->child_pcb_list = grandchildren;
        }else{
            pcb_node_t *tmp = grandchildren->previous;

            children->previous->next = grandchildren;
            grandchildren->previous = children->previous;
            children->previous = tmp;
            tmp->next = children;
        }

        // change parent pointers
        pcb_node_t *current_pcb_node = child_pcb->child_pcb_list;
        while (current_pcb_node->data.parent_pcb_ptr != init_pcb)
        {
            current_pcb_node->data.parent_pcb_ptr = init_pcb;
            current_pcb_node = current_pcb_node->next;
        }
    }
    if (pcb_ptr != init_pcb)
    {
        mutex_unlock(&(init_pcb->lock));
    }
    
    mutex_unlock(&(pcb_ptr->lock));

    // free tcb list
    tcb_node_t *current_tcb_list = child_pcb->tcb_list;
    ureg_ptr->eax = current_tcb_list->data.tid;
    while (current_tcb_list)
    {
        POP_FRONT(tcb_node_t, current_tcb_list);
    }

    // free all tcb in TERMINATED list
    while(thread_lists[TERMINATED_STATE]){
        POP_FRONT(tcb_ptr_node_t, thread_lists[TERMINATED_STATE]);
    }

    if (status_ptr){
        *status_ptr = child_pcb->status;
    }
    
    // free page dir
    destruct_page_dir(child_pcb->page_directory);
    mutex_destroy(&(child_pcb->lock));

    // free alloc list
    while (child_pcb->page_allocation_list)
    {
        POP_FRONT(page_allocation_node_t, child_pcb->page_allocation_list);
    }

    // delete child
    POP_FRONT(pcb_node_t, child_pcb_node);

    // wake up next waiting thread, parent and init
    disable_interrupts();
    tcb_t *next_tcb = find_tcb_in_list(pcb_ptr, VANISH_WAIT);
    if (next_tcb)
    {
        alter_state(next_tcb, READY_STATE, NULL);
    }    
    tcb_t *init_tcb = find_tcb_in_list(init_pcb, VANISH_WAIT);
    if (init_tcb)
    {
        alter_state(init_tcb, READY_STATE, NULL);
    }    
    enable_interrupts();
}

void handle_vanish(ureg_t *ureg_ptr) {
    pcb_t *pcb_ptr = thread_lists[RUNNING_STATE]->data->pcb_ptr;

    mutex_lock(&(pcb_ptr->lock));
    int thread_alive_count;
    affirm(!get_thread_alive_count(pcb_ptr, &thread_alive_count));

    tcb_t *next_tcb;

    disable_interrupts();
    if (thread_alive_count == 1)
    {
        // Last thread, find waiting tasks
        next_tcb = find_tcb_in_list(pcb_ptr->parent_pcb_ptr, VANISH_WAIT);
        if (next_tcb)
        {
            alter_state(next_tcb, READY_STATE, NULL);
        }
        
        // RR next
        next_tcb = round_robin();

        // Nothing found, halt
        if (next_tcb == NULL)
        {
            ureg_t ureg = {.cause = 0};
            handle_halt(&ureg);
        }
        void *cr3 = (void*) get_cr3();
        sim_unreg_process(cr3);
    }else{
        // Find next thr
        next_tcb = find_next_thread();
    }
    mutex_unlock(&(pcb_ptr->lock));
    switch_context(next_tcb, TERMINATED_STATE, NULL);
    enable_interrupts();
}

void handle_task_vanish(ureg_t *ureg_ptr) {
    int status = (int) ureg_ptr->esi;
    tcb_t *tcb_ptr = thread_lists[RUNNING_STATE]->data;
    pcb_t *pcb_ptr = tcb_ptr->pcb_ptr;
    mutex_lock(&(pcb_ptr->lock));
    disable_interrupts();
    tcb_node_t *node_ptr = pcb_ptr->tcb_list;
    do {
        if (&(node_ptr->data) != tcb_ptr) {
            alter_state(&(node_ptr->data), TERMINATED_STATE, NULL);
        }
        node_ptr = node_ptr->next;
    } while (node_ptr != pcb_ptr->tcb_list);
    enable_interrupts();
    mutex_unlock(&(pcb_ptr->lock));
    pcb_ptr->status = status;
    ureg_t ureg = {.cause = 0};
    handle_vanish(&ureg);
}

void handle_set_status(ureg_t *ureg_ptr) {
    int status = (int) ureg_ptr->esi;
    pcb_t *pcb_ptr = thread_lists[RUNNING_STATE]->data->pcb_ptr;
    pcb_ptr->status = status;
}

void handle_print(ureg_t *ureg_ptr) {
    void **arg_array = (void **)ureg_ptr->esi;
    int len = (int)arg_array[0];
    char *buf = arg_array[1];

    if (len < 0 || !is_readable((uint32_t)buf, len)) {
        ureg_ptr->eax = -1;
        return;
    }
    
    mutex_lock(&output_lock);
    putbytes(buf, len);
    mutex_unlock(&output_lock);

    ureg_ptr->eax = 0;
}

void handle_readline(ureg_t *ureg_ptr) {
    void **arg_array = (void **)ureg_ptr->esi;
    int len = (int)arg_array[0];
    char *buf = arg_array[1];

    if (len < 0 || len > BUF_LEN || !is_writable((uint32_t)buf, len)) {
        ureg_ptr->eax = -1;
        return;
    }

    if (len == 0) {
        ureg_ptr->eax = 0;
        return;
    }

    tcb_t *original_tcb_ptr = thread_lists[RUNNING_STATE]->data;
    mutex_lock(&(original_tcb_ptr->pcb_ptr->lock));
    disable_interrupts();
    if (mutex_try_lock(&input_lock) < 0) {
        tcb_t *target_tcb_ptr = find_next_thread();
        if (target_tcb_ptr == NULL) {
            ureg_t ureg = {.cause = 0};
            handle_halt(&ureg);
        }
        blocking_detail_t blocking_detail = {
            .reason = READLINE,
            .first_reader = false
        };
        mutex_unlock(&(original_tcb_ptr->pcb_ptr->lock));
        switch_context(target_tcb_ptr, WAITING_STATE, &blocking_detail);
        mutex_try_lock(&input_lock);
        enable_interrupts();
    } else {
        enable_interrupts();
        mutex_unlock(&(original_tcb_ptr->pcb_ptr->lock));
    }

    if (ch_buf.element_count > 0) {
        int ch_count = 0;
        char ch;
        while (ch_count < len && !(pop_head(&ch_buf, &ch) < 0)) {
            buf[ch_count] = ch;
            ch_count++;
        }
        ureg_ptr->eax = ch_count;
    
        disable_interrupts();
        mutex_unlock(&input_lock);
        if (thread_lists[READLINE] != NULL) {
            switch_context(thread_lists[READLINE]->data, READY_STATE, NULL);
        }
        enable_interrupts();
        return;
    }

    bool newline = false;
    while (!newline) {
        char ch;
        mutex_lock(&(original_tcb_ptr->pcb_ptr->lock));
        disable_interrupts();
        while (extract_ch(&scancode_buf, &ch) < 0) {
            tcb_t *target_tcb_ptr = find_next_thread();
            if (target_tcb_ptr == NULL) {
                ureg_t ureg = {.cause = 0};
                handle_halt(&ureg);
            }
            blocking_detail_t blocking_detail = {
                .reason = READLINE,
                .first_reader = true
            };
            mutex_unlock(&(original_tcb_ptr->pcb_ptr->lock));
            switch_context(target_tcb_ptr, WAITING_STATE, &blocking_detail);
            enable_interrupts();

            mutex_lock(&(original_tcb_ptr->pcb_ptr->lock));
            disable_interrupts();
        }
        enable_interrupts();
        mutex_unlock(&(original_tcb_ptr->pcb_ptr->lock));
    
        mutex_lock(&output_lock);
        putbyte(ch);
        mutex_unlock(&output_lock);

        switch (ch) {
            case KHE_BACKSPACE: {
                pop_tail(&ch_buf, &ch);
                break;
            }
            case KHE_ENTER: {
                push_tail(&ch_buf, ch);
                newline = true;
                break;
            }
            default: {
                push_tail(&ch_buf, ch);
                break;
            }
        }
    }

    int ch_count = 0;
    char ch;
    while (ch_count < len && !(pop_head(&ch_buf, &ch) < 0)) {
        buf[ch_count] = ch;
        ch_count++;
    }
    ureg_ptr->eax = ch_count;

    disable_interrupts();
    mutex_unlock(&input_lock);
    if (thread_lists[READLINE] != NULL) {
        switch_context(thread_lists[READLINE]->data, READY_STATE, NULL);
    }
    enable_interrupts();
}

void handle_getchar(ureg_t *ureg_ptr) {
    // not implemented
    ureg_ptr->eax = -1;
}

void handle_new_pages(ureg_t *ureg_ptr) {
    pcb_t *pcb_ptr = thread_lists[RUNNING_STATE]->data->pcb_ptr;
    mutex_lock(&(pcb_ptr->lock));

    void **arg_array = (void **)ureg_ptr->esi;
    void *base = arg_array[0];
    int len = (int)arg_array[1];

    uint32_t page = ((uint32_t)base >> PAGE_SHIFT) << PAGE_SHIFT;
    if (page != (uint32_t)base) {
        ureg_ptr->eax = -1;
        mutex_unlock(&(pcb_ptr->lock));
        return;
    }
    int page_count = len / PAGE_SIZE;
    if (!(
        page_count > 0 &&
        page_count < machine_phys_frames() - USER_PAGE_START / PAGE_SIZE &&
        page_count * PAGE_SIZE == len
    )) {
        ureg_ptr->eax = -1;
        mutex_unlock(&(pcb_ptr->lock));
        return;
    }

    pde_t *page_dir = (pde_t *)((get_cr3() >> PAGE_SHIFT) << PAGE_SHIFT);
    for (uint32_t i = 0; i < page_count; i++) {
        uint32_t current_page = page + i * PAGE_SIZE;
        uint32_t availability;
        if (!(
            get_availability(page_dir, current_page, &availability) < 0 ||
            availability != PAGE_UNAVAILABLE ||
            set_availability(page_dir, current_page, PAGE_AVAILABLE) < 0
        )) {
            if (!(map_new_frame(page_dir, current_page) < 0)) {
                memset((void *)current_page, 0, PAGE_SIZE);
                continue;
            }
            set_availability(
                page_dir,
                current_page,
                PAGE_UNAVAILABLE
            );
        }
        for (uint32_t j = 0; j < i; j++) {
            uint32_t previous_page = page + j * PAGE_SIZE;
            unmap_frame(page_dir, previous_page);
            set_availability(
                page_dir,
                previous_page,
                PAGE_UNAVAILABLE
            );
        }
        ureg_ptr->eax = -1;
        mutex_unlock(&(pcb_ptr->lock));
        return;
    }

    page_allocation_t page_allocation = {
        .base = base,
        .len = len
    };
    bool success;
    if (
        pcb_ptr->page_allocation_list == NULL ||
        pcb_ptr->page_allocation_list->data.base >= base
    ) {
        PUSH_FRONT(
            page_allocation_node_t,
            pcb_ptr->page_allocation_list,
            page_allocation,
            success
        );
    } else {
        page_allocation_node_t *node_ptr = pcb_ptr->page_allocation_list->next;
        while (
            node_ptr != pcb_ptr->page_allocation_list &&
            node_ptr->data.base < base
        ) {
            node_ptr = node_ptr->next;
        }
        PUSH_FRONT(
            page_allocation_node_t,
            node_ptr,
            page_allocation,
            success
        );
    }
    if (!success) {
        for (uint32_t i = 0; i < page_count; i++) {
            uint32_t previous_page = page + i * PAGE_SIZE;
            unmap_frame(page_dir, previous_page);
            set_availability(
                page_dir,
                previous_page,
                PAGE_UNAVAILABLE
            );
        }
        ureg_ptr->eax = -1;
        mutex_unlock(&(pcb_ptr->lock));
        return;
    }

    ureg_ptr->eax = 0;
    mutex_unlock(&(pcb_ptr->lock));
}

void handle_remove_pages(ureg_t *ureg_ptr) {
    pcb_t *pcb_ptr = thread_lists[RUNNING_STATE]->data->pcb_ptr;
    mutex_lock(&(pcb_ptr->lock));

    void *base = (void *)ureg_ptr->esi;

    bool success = false;
    uint32_t cr3 = get_cr3();
    pde_t *page_dir = (pde_t *)((cr3 >> PAGE_SHIFT) << PAGE_SHIFT);
    if (pcb_ptr->page_allocation_list != NULL) {
        page_allocation_node_t *node_ptr = pcb_ptr->page_allocation_list;
        do {
            if (node_ptr->data.base == base) {
                int len = node_ptr->data.len;
                if (node_ptr == pcb_ptr->page_allocation_list) {
                    POP_FRONT(
                        page_allocation_node_t,
                        pcb_ptr->page_allocation_list
                    );
                } else {
                    POP_FRONT(
                        page_allocation_node_t,
                        node_ptr
                    );
                }
                for (uint32_t i = 0; i < len; i += PAGE_SIZE) {
                    uint32_t v_addr = (uint32_t)base + i;
                    if (
                        unmap_frame(page_dir, v_addr) < 0 ||
                        set_availability(page_dir, v_addr, PAGE_UNAVAILABLE) < 0
                    ) {
                        ureg_ptr->eax = -1;
                        mutex_unlock(&(pcb_ptr->lock));
                        return;
                    }
                }
                success = true;
                break;
            }
            node_ptr = node_ptr->next;
        } while (
            node_ptr != pcb_ptr->page_allocation_list &&
            node_ptr->data.base < base
        );
    }
    if (!success) {
        ureg_ptr->eax = -1;
        mutex_unlock(&(pcb_ptr->lock));
        return;
    }

    set_cr3(cr3);
    ureg_ptr->eax = 0;
    mutex_unlock(&(pcb_ptr->lock));
}

void handle_swexn(ureg_t *ureg_ptr) {
    void **arg_array = (void **)ureg_ptr->esi;
    void *exception_stack = arg_array[0];
    void (*handler)(void *arg, ureg_t *ureg_ptr) = arg_array[1];
    void *arg = arg_array[2];
    ureg_t *new_ureg_ptr = arg_array[3];

    bool success = true;
    if (exception_stack != NULL && handler != NULL) {
        if (
            !is_writable(
                (uint32_t)exception_stack - EXCEPTION_STACK_SIZE_MIN,
                EXCEPTION_STACK_SIZE_MIN
            ) ||
            !is_readable(
                (uint32_t)handler,
                HANDLER_SIZE_MIN
            )
        ) {
            success = false;
        }
    }
    if (success) {
        if (new_ureg_ptr != NULL) {
            if (
                !is_readable((uint32_t)new_ureg_ptr, sizeof(ureg_t)) ||
                !check_eflags(ureg_ptr->eflags, new_ureg_ptr->eflags)
            ) {
                success = false;
            }
        }
    }
    if (!success) {
        ureg_ptr->eax = -1;
        return;
    }

    ureg_ptr->eax = 0;

    tcb_t *current_tcb_ptr = thread_lists[RUNNING_STATE]->data;
    if (exception_stack != NULL && handler != NULL) {
        current_tcb_ptr->exception_stack = exception_stack;
        current_tcb_ptr->handler = handler;
        current_tcb_ptr->arg = arg;
    } else {
        current_tcb_ptr->exception_stack = NULL;
    }
    if (new_ureg_ptr != NULL) {
        load_ureg(new_ureg_ptr);
    }
}

void handle_sleep(ureg_t *ureg_ptr) {
    int ticks = ureg_ptr->esi;

    if (ticks < 0) {
        ureg_ptr->eax = -1;
        return;
    }

    if (ticks == 0) {
        ureg_ptr->eax = 0;
        return;
    }

    tcb_t *original_tcb_ptr = thread_lists[RUNNING_STATE]->data;
    mutex_lock(&(original_tcb_ptr->pcb_ptr->lock));
    disable_interrupts();
    tcb_t *target_tcb_ptr = find_next_thread();
    if (target_tcb_ptr == NULL) {
        ureg_t ureg = {.cause = 0};
        handle_halt(&ureg);
    }
    blocking_detail_t blocking_detail = {
        .reason = SLEEP,
        .wakeup_time = tick_count + ticks
    };
    mutex_unlock(&(original_tcb_ptr->pcb_ptr->lock));
    switch_context(target_tcb_ptr, WAITING_STATE, &blocking_detail);
    enable_interrupts();
    ureg_ptr->eax = 0;
}

void handle_readfile(ureg_t *ureg_ptr) {
    void **arg_array = (void **)ureg_ptr->esi;
    char *filename = arg_array[0];
    char *buf = arg_array[1];
    int count = (int)arg_array[2];
    int offset = (int)arg_array[3];

    if (count < 0 || !is_writable((uint32_t)buf, count)) {
        ureg_ptr->eax = -1;
        return;
    }

    int byte_count = getbytes(filename, offset, count, buf);
    if (byte_count == -1) {
        ureg_ptr->eax = -1;
        return;
    }

    ureg_ptr->eax = byte_count;
}

void handle_thread_fork(ureg_t *ureg_ptr) {
    tcb_t *tcb_ptr = thread_lists[RUNNING_STATE]->data;
    pcb_t *pcb_ptr = tcb_ptr->pcb_ptr;
    mutex_lock(&(pcb_ptr->lock));
    int new_tid = thread_fork_ctrl_blk(ureg_ptr);
    mutex_unlock(&(pcb_ptr->lock));
    if (new_tid < 0) {
        ureg_ptr->eax = -1;
    } else {
        ureg_ptr->eax = new_tid;
    }
}

void handle_get_ticks(ureg_t *ureg_ptr) {
    ureg_ptr->eax = tick_count;
}

void handle_set_term_color(ureg_t *ureg_ptr) {
    int color = ureg_ptr->esi;
    mutex_lock(&output_lock);
    bool success = !(set_term_color(color) < 0);
    mutex_unlock(&output_lock);
    if (!success) {
        ureg_ptr->eax = -1;
        return;
    }
    ureg_ptr->eax = 0;
}

void handle_set_cursor_pos(ureg_t *ureg_ptr) {
    void **arg_array = (void **)ureg_ptr->esi;
    int row = (int)arg_array[0];
    int col = (int)arg_array[1];
    mutex_lock(&output_lock);
    bool success = !(set_cursor(row, col) < 0);
    mutex_unlock(&output_lock);
    if (!success) {
        ureg_ptr->eax = -1;
        return;
    }
    ureg_ptr->eax = 0;
}

void handle_get_cursor_pos(ureg_t *ureg_ptr) {
    void **arg_array = (void **)ureg_ptr->esi;
    int *row = arg_array[0];
    int *col = arg_array[1];
    if (
        !is_writable((uint32_t)row, sizeof(int)) ||
        !is_writable((uint32_t)col, sizeof(int))
    ) {
        ureg_ptr->eax = -1;
        return;
    }
    mutex_lock(&output_lock);
    get_cursor(row, col);
    mutex_unlock(&output_lock);
    ureg_ptr->eax = 0;
}

void handle_new_console(ureg_t *ureg_ptr) {
    ureg_ptr->eax = -1;
}
